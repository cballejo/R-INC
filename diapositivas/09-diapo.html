<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Estructuras de control de flujo</title>
    <meta charset="utf-8" />
    <meta name="author" content="Instituto Nacional de Epidemiología" />
    <script src="libs/header-attrs/header-attrs.js"></script>
    <link rel="stylesheet" href="xaringan-themer.css" type="text/css" />
    <link rel="stylesheet" href="animate.min.css" type="text/css" />
    <link rel="stylesheet" href="fonts_mtheme.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

.title[
# Estructuras de control de flujo
]
.author[
### Instituto Nacional de Epidemiología
]
.date[
### 4-12-2023
]

---


layout: true
class: animated, fadeIn






&lt;style type="text/css"&gt;
.code {
  color: #777;
  width: 48%;
  height: 92%;
  float: left;
}
.plot {
  width: 50%;
  height: 70%;
  float: right;
  padding-left: 1%;
}
&lt;/style&gt;

---
## Control del flujo de ejecución

.font150[
El flujo de ejecución del lenguage R es secuencial, es decir, las líneas de código corren una debajo de la otra.

Las estructuras de control de flujo son utilizadas en programación para modificar el flujo de ejecución secuencial de estas líneas de código y producir bucles o bifurcaciones a partir de condiciones.

Estas estructuras están presentes en todos los lenguajes de programación, lo que varía entre ellos es su sintaxis.

El lenguaje R como tal, trae incorporadas estas funciones en su base.

]

---
## Bucles

.font160[
Los bucles (o *“loops"* en inglés) son estructuras especiales que sirven para ejecutar una tarea una cantidad arbitraria de veces.

A cada una de estas repeticiones se la denomina **iteración**. 

En definitiva, sirven para hacer en forma automática un proceso que llevaría escribir muchas más líneas de código.

Los comandos más comunes y universales para hacer bucles en programación son las funciones **for** y **while**.

]
---
## Función for()

.pull-left[.font150[
Usamos la función **for()** cuando es necesario repetir la ejecución de un mismo grupo de instrucciones una cantidad de determinada de veces.

La cantidad de iteraciones suele definirse a partir de recorrer la longitud de un objeto (*por ejemplo, el número de observaciones de un dataframe o el número de elementos de un vector*)
]]

.pull-right[
&lt;img src="assets/for.PNG" width="80%" style="display: block; margin: auto;" /&gt;
]

---
## Función while()

.pull-left[.font150[
Como su nombre en inglés lo indica, **while()** (*mientras*) es un bucle que se ejecutará solamente mientras la o las condiciones especificadas se cumplan, interrumpiéndose inmediatamente cuando dejen de hacerlo.

Es decir, es un bucle manejado por una condición lógica.

]]

.pull-right[
&lt;img src="assets/while.PNG" width="80%" style="display: block; margin: auto;" /&gt;
]
---
## Bucle repeat - break

.font150[
Existe otra estructura tipo bucle, poco utilizada por considerarse peligrosa, cuya función es **repeat()**.

Es la más simple de todas:  se limita a repetir funciones hasta que el usuario de una orden de finalización. La  forma de determinar la finalización es usando **break()**.

Es peligrosa porque muchas veces las iteraciones pueden producirse infinitamente, dado que depende exclusivamente del usuario que controla el break() mediante código.
]

---
## Condicional if-else

.pull-left[.font150[
Es la estructura que permite que se bifurquen los caminos del flujo de ejecución en un script.

Consta de una condición que nos arroja uno de dos posibles resultados: Verdadero o Falso. En función de estos, se ejecutan las líneas de código para el Si o de lo contrario (**else**) para el No.

La diferencia con **if_else()** es que permite multiplicidad de líneas a ejecutar luego de la condición.
]]

.pull-right[
&lt;img src="assets/if_else.PNG" width="100%" style="display: block; margin: auto;" /&gt;
]


    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false,
"ratio": "16:9"
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>
<style>
.logo {
  background-image: url(logo_INE.PNG);
  background-size: contain;
  background-repeat: no-repeat;
  position: absolute;
  top: 1em;
  right: 1em;
  width: 55px;
  height: 64px;
  z-index: 0;
}
</style>

<script>
document
  .querySelectorAll(
    '.remark-slide-content' +
    ':not(.title-slide)' +
    // add additional classes to exclude here, e.g.
    // ':not(.inverse)' +
    ':not(.hide-logo)'
  )
  .forEach(el => {
    el.innerHTML += '<div class="logo"></div>';
  });
</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
